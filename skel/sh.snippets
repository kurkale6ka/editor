# Hash bang using the env command
snippet #
#! /usr/bin/env ${1:bash}
endsnippet

snippet read
read -p '${1:Enter value:}' ${2:var}
endsnippet

snippet p
printf '%s\n' ${1}
endsnippet

snippet doc
cat << 'EOM'
${1}
EOM
endsnippet

snippet fun
${1:name}() {
   ${2:commands}
}
endsnippet

snippet alias
alias ${1:name}='${2}'
endsnippet

snippet _
/dev/null
endsnippet

snippet trap
trap '${1:exit 0}' ${2:INT TERM}
endsnippet

snippet \\
# Run batches of up to 30 (read explanation below) jobs in parallel
# When you reach a certain number of bg processes, bash starts disowning
# the oldest processes, meaning you lose control over them
((i++)); ((i % 30 == 0) && wait
endsnippet

## Skeleton
snippet skel
#! /usr/bin/env bash

# ${1:Short Description}
#
# Author: `g:snips_author` <mitkofr@yahoo.fr>
# -------------------------------------------

${2:shopt -s extglob}
endsnippet

## Loops
snippet for "for variable in words" !
for ${1:i} in ${2:"\$@"}
do
   ${3:echo} "\$$1"
done
endsnippet

snippet for "for variable in range"
for ${1:i} in \{${2:start}..${3:end}}
do
   ${4:echo} "\$$1"
done
endsnippet

snippet for "C-like for"
for ((${1:i} = ${2:0}; $1 < ${3:10}; $1++))
do
   ${4:commands}
done
endsnippet

snippet while
while ${1:command}
do
   ${2:commands}
done
endsnippet

snippet until
until ${1:command}
do
   ${2:commands}
done
endsnippet

## Switch / select
snippet case "Case" !
case "\$${1:variable}" in
   ${2:glob1}) ${3:command};;
   ${4:glob2}) ${5:command};;
   ${6:glob3}) ${7:command};;
   *) ${8:default_command};;
esac
endsnippet

snippet case "Select"
options[0]='${1}'
options[1]='${2}'
options[2]='${3}'

select choice in "${options[@]}"
do
   case "$choice" in
      "${options[0]}") ${4}; break;;
      "${options[1]}") ${5}; break;;
      "${options[2]}") ${6}; break;;
   esac
   echo '*** Wrong choice ***'
done
endsnippet

## if
snippet if "Commands" !
if ${1:commands}
then
   ${2:commands}
fi
endsnippet

snippet if "String comparison"
if [[ ${1:'test'} ${2:==} ${3:\$right_operand} ]]
then
   ${4:commands}
fi
endsnippet

snippet if "Digit comparison"
if (( ${1:0} ${2:<} ${3:j} ))
then
   ${4:commands}
fi
endsnippet

## Arrays
snippet [ "Create an array"
${1:array}=(${2:words})
endsnippet

snippet [ "Use an array"
"${${1:array}[@]}"
endsnippet

## help
snippet h
shopt -s extglob

if [[ \$1 == -@(h|-h)* ]] || (($# == 0))
then
   info='Usage: ${1}'
   if (($#))
   then echo "$info"    ; exit 0
   else echo "$info" >&2; exit 1
   fi
fi
endsnippet

snippet help
shopt -s extglob

if [[ \$1 == -@(h|-h)* ]] || (($# == 0))
then
read -r -d $'\0' info << 'HELP'
Usage: ${1}
HELP
   if (($#))
   then echo "$info"    ; exit 0
   else echo "$info" >&2; exit 1
   fi
fi
endsnippet

## read a 'file'
snippet <> "Read a heredoc"
while read -r ${1:line}
do
   [[ $$1 = \#* || ! $host ]] && continue
   echo "$$1"
done << EOF
${2}
EOF
endsnippet

snippet <> "Read find's output"
while read -r -d \$'\0'
do
   ${1:"\$REPLY"}
done < <(${2:find /foo -print0})
endsnippet

## Extended globs
snippet ext "Enable extended globs"
shopt -s extglob
endsnippet

snippet ext "Use extended globs"
${1:@?*+!}(${2:item1}|${3:item2})
endsnippet

## $1 $2 $3 $4 $5 $6 $7 $8 $9
snippet 0
"\$${1:0}"${2}
endsnippet

snippet 1
"\$${1:1}"${2}
endsnippet

snippet 2
"\$${1:2}"${2}
endsnippet

snippet 3
"\$${1:3}"${2}
endsnippet

snippet 4
"\$${1:4}"${2}
endsnippet

snippet 5
"\$${1:5}"${2}
endsnippet

snippet 6
"\$${1:6}"${2}
endsnippet

snippet 7
"\$${1:7}"${2}
endsnippet

snippet 8
"\$${1:8}"${2}
endsnippet

snippet 9
"\$${1:9}"${2}
endsnippet

## Parameter expansion
snippet / "remove 1 from start"
\$\{${1:parameter}#${2:word to remove}}
endsnippet

snippet / "remove ALL from start"
\$\{${1:parameter}##${2:word to remove}}
endsnippet

snippet / "remove 1 from end"
\$\{${1:parameter}%${2:word to remove}}
endsnippet

snippet / "remove ALL from end"
\$\{${1:parameter}%%${2:word to remove}}
endsnippet

snippet / "s///"
\$\{${1:parameter}/${2:old}/${3:new}}
endsnippet

snippet / "s/// ALL"
\$\{${1:parameter}//${2:old}/${3:new}}
endsnippet

snippet / "substring in parameter"
\$\{${1:parameter}:${2:start (0, ...)}${3::}${4:length (or everything)}}
endsnippet

snippet / "file.ext (remove everything in front)"
\$\{${1:file name}##*/}
endsnippet

snippet / "Remove extension of file"
\$\{${1:file name}%.*}
endsnippet

snippet / "length of parameter"
\$\{#${1:parameter}}
endsnippet

snippet / "all parameters starting with prefix"
\$\{!${1:prefix}@}
endsnippet

snippet / "Parameter expansion on arrays"
\$\{${1:parameters array}[@]${2}#%:/}
endsnippet

## Error
snippet e
1>&2
endsnippet

snippet E
cat 1>&2 << 'HELP'
${1}
HELP
endsnippet

## /etc/init.d/script
snippet init
#! /usr/bin/env bash

# Never use PID files: http://mywiki.wooledge.org/ProcessManagement
# Try daemontools or runit instead!
# https://github.com/imeyer/runit-rpm
#
# chkconfig: 345 81 11
# description: $1

trap 'rm -f /mnt/nas/repos/$2.pid' HUP INT KILL TERM

h() { echo 'Usage: $2 {status|stop|start|restart}' >&2; }

(($# != 1)) && { h; exit 1; }

Bold="$(tput bold)"
LG="$(printf %s "$Bold"; tput setaf 2)"
LR="$(printf %s "$Bold"; tput setaf 1)"
Reset="$(tput sgr0)"

status() {
   local $2_pid="$(</mnt/nas/repos/$2.pid)"
   if (($2_pid)) && kill -0 "$$2_pid"
   then echo "${2/\w/\u$0/} is running with PID: $Bold$$2_pid$Reset"
   else echo '${2/\w/\u$0/} is not running' >&2; exit 3
   fi
}

stop() {
   printf '%-31s' 'Stopping ${2/\w/\u$0/}...'
   local $2_pid="$(</mnt/nas/repos/$2.pid)"
   if (($2_pid)) && kill "$$2_pid"
   then echo "[ ${LG}OK$Reset ]"
   else echo "[ ${LR}FAILED$Reset ]" >&2; exit 4
   fi
}

start() {
   printf '%-31s' 'Starting ${2/\w/\u$0/}...'
   # Enable logging >/var/log/$2 2>&1 & ?
   if /mnt/nas/repos/$2 >/dev/null 2>&1 & then
      $2_pid="$!"
      # If the script dies here, we have a running process and a wrong PID file!
      # Solution: delete the PID file in the trap.
      if echo "$$2_pid" > /mnt/nas/repos/$2.pid; then
         echo "[ ${LG}OK$Reset ] (PID: $Bold$$2_pid$Reset)"
      else
         echo 'Failed to create PID file' >&2
         kill "$$2_pid"; exit 5
      fi
   else
      echo "[ ${LR}FAILED$Reset ]" >&2; exit 6
   fi
}

restart() { stop && start; }

case "\$1" in
    status) status    ;;
      stop) stop      ;;
     start) start     ;;
   restart) restart   ;;
         *) h; exit 2 ;;
esac
endsnippet

# vim: foldmethod=expr foldexpr=getline(v\:lnum)=~'^##'?'>1'\:'='
