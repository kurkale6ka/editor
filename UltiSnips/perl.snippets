snippet #
#! /usr/bin/env perl

use strict;
use warnings;
use feature 'say';


endsnippet

snippet ##
#! /usr/bin/env perl

use strict;
use warnings;
use feature 'say';
use File::Glob ':bsd_glob';
use Term::ANSIColor qw/color :constants/;
use Getopt::Long qw/GetOptions :config bundling/;
use File::Basename 'basename';
use File::Path 'make_path';
use List::Util 'any';

my $BLUE = color('ansi69');
my $CYAN = color('ansi45');
my $S = color('bold');
my $R = color('reset');

# Help
sub help() {
   print <<MSG;
${S}SYNOPSIS${R}
${S}OPTIONS${R}
${S}DESCRIPTION${R}
MSG
   exit;
}

# Arguments
GetOptions (
   'h|help' => \&help
) or die RED.'Error in command line arguments'.RESET, "\n";


endsnippet

# Use
snippet use "File::Glob"
use File::Glob ':bsd_glob';
endsnippet

snippet 'use|colors' "Term::ANSIColor" r
use Term::ANSIColor qw/color :constants/;

my $BLUE = color('ansi69');
my $CYAN = color('ansi45');
my $GRAY = color('ansi242');
my $PINK = color('ansi205');
my $S = color('bold');
my $R = color('reset');
endsnippet

snippet 'use|opts' "Getopt::Long" r
use Getopt::Long qw/GetOptions :config bundling/;

# Help
sub help() {
   print <<MSG;
${S}SYNOPSIS${R}
${S}OPTIONS${R}
${S}DESCRIPTION${R}
MSG
   exit;
}

# Arguments
my \$$1;
GetOptions (
   '`!p snip.rv = t[1][0:1]`|`!p snip.rv = t[1]`' => \\$$1,
   'h|help' => \&help
) or die RED.'Error in command line arguments'.RESET, "\n";
endsnippet

snippet opt
'`!p snip.rv = t[1][0:1]`|$1' => \\$$1,
endsnippet

snippet use "File::Basename"
use File::Basename 'basename';
endsnippet

snippet use "File::Path"
use File::Path 'make_path';
endsnippet

snippet use "List::Util"
use List::Util 'any';
endsnippet

# Print
snippet '(die|warn)' "err" r
`!p snip.rv = match.group(1)` RED.${1:"$!"}.RESET, "\n";
endsnippet

snippet dump
use Data::Dumper;
say Dumper
endsnippet

snippet doc
print <<${1:MSG};
$2
$1
endsnippet

# Open
snippet 'open|read' "File" r
open my \$${1:fh}, '${2:<}', '${3:file}';

while (<\$$1>)
{
   chomp;
   $4
}
endsnippet

snippet read "Pipe"
open my \$${1:fh}, '-|', '${2:command}';

while (<\$$1>)
{
   chomp;
   $3
}
endsnippet

snippet read "STDIN"
print '$1: ';
chomp (${2:$_} = <STDIN>);


endsnippet

snippet '<>|read' "DATA or files" r
while (${1:<DATA>})
{
   chomp;
   $2
}
endsnippet

snippet yes
<STDIN> =~ /y(?:es)?/i;
endsnippet

snippet |
open my \$${1:fh}, '|-', '${2:command}';
endsnippet

# Array
snippet '\[|@' "array" r
my @${1:array} = qw/${2:word1} ${3:word2} ${4:word3}/;
endsnippet

snippet %
my %$1 =
(
   $2 => '$3',
   $4 => '$5',
);
endsnippet

snippet each
while (my (\$${1:key}, \$${2:val}) = each %$3)
{
   $4;
}
endsnippet

snippet env
$ENV{$1}
endsnippet

snippet xdg "~/.config"
$ENV{XDG_CONFIG_HOME}
endsnippet

snippet xdg "~/.local"
$ENV{XDG_DATA_HOME}
endsnippet

# Misc
# todo: stopinsert...
snippet '} else'
} else {
}
endsnippet

snippet ?
${1:cond} ? ${2:true} : ${3:false}
endsnippet

snippet =
my (\$$1, \$$2, \$$3) = $4;
endsnippet

snippet root
(getpwuid $>)[0] eq 'root'
endsnippet

snippet 'sys(tem)?' "system()" r
system qw/$1/;
endsnippet

snippet fork "One"
use POSIX ":sys_wait_h";

my $pid = fork // die "failed to fork: $!";

# kid
if ($pid == 0)
{
   $1;
   exit;
}

waitpid $pid, WNOHANG;
endsnippet

snippet fork "Many"
my @children;

foreach ($1)
{
   # parent
   my $pid = fork // die "failed to fork: $!";

   if ($pid)
   {
      push @children, $pid;
      next;
   }

   # kid
   $2;
   exit;
}

waitpid $_, 0 foreach @children;
endsnippet

snippet os
$^O eq '${1:linux}'
endsnippet

# __END__
snippet '(data|end)' "DATA" r
__`!p snip.rv = match.group(1).upper()`__
endsnippet
